import _ from 'lodash';

import {Tensor} from './tensor';

// Moving directions. We allow only four of them:
export const directions = ['>', '^', '<', 'v'];

export function directionToAngle(direction){
  return {
    '>': 0,
    '^': 90,
    '<': 180,
    'v': 270,
  }[direction];
}
export function angleToDirection(angle) {
  return {
    '0': '>',
    '90': '^',
    '180': '<',
    '270': 'v',
  }['' + angle];
}

export const identity = Tensor.fill(directions, {re: 1, im: 0});
export const zero = Tensor.fill(directions, {re: 0, im: 0});

// Reflection direction: reflecting from point
export function pointReflectionDirection(direction) {
  const incidentAngle = directionToAngle(direction);
  const reflectedAngle = (incidentAngle + 180) % 360;
  return angleToDirection(reflectedAngle);
}

// Reflection direction basing on plane's rotation (- / | \)
export function planeReflectionDirection(direction, rotation) {
  const mirrorPlaneAngle = rotation * 45;
  const incidentAngle = directionToAngle(direction);
  const reflectedAngle = (2 * mirrorPlaneAngle - incidentAngle + 360) % 360;
  return angleToDirection(reflectedAngle);
}

export const cube = Tensor.fromObject(
  _.reduce(directions, (acc, dirFrom) => {
    const dirTo = pointReflectionDirection(dirFrom);
    acc[dirFrom] = {};
    acc[dirFrom][dirTo] = {re: 1, im: 0};
    return acc;
  }, {})
);

export const mirror = _.range(4).map((rotation) => {
  return Tensor.fromObject(
    _.reduce(directions, (acc, dirFrom) => {
      const dirTo = planeReflectionDirection(dirFrom, rotation);
      acc[dirFrom] = {};
      if (dirFrom !== dirTo) {
        acc[dirFrom][dirTo] = {re: 1, im: 0};
      }
      return acc;
    }, {})
  );
});

export const mirrorCoated = _.range(8).map((rotation) => {
  return Tensor.fromObject(
    _.reduce(directions, (acc, dirFrom, iFrom) => {
      const dirTo = planeReflectionDirection(dirFrom, rotation);
      const sign = (-rotation/2 + iFrom + 8) % 4 < 1.75 ? -1 : 1;
      acc[dirFrom] = {};
      if (dirFrom !== dirTo) {
        acc[dirFrom][dirTo] = {re: sign, im: 0};
      }
      return acc;
    }, {})
  );
});

export const diode = _.range(4).map((rotation) => {
  return Tensor.fromObject(
    _.reduce(directions, (acc, dirFrom) => {
      acc[dirFrom] = {};
      if (dirFrom === directions[rotation]) {
        acc[dirFrom][dirFrom] = {re: 1, im: 0};
      }
      return acc;
    }, {})
  );
});

export const absorbOneDirReflectOther = _.range(4).map((rotation) => {
  return Tensor.fromObject(
    _.reduce(directions, (acc, dirFrom, iFrom) => {
      const dirTo = pointReflectionDirection(dirFrom);
      acc[dirFrom] = {};
      if (rotation !== iFrom) {
        acc[dirFrom][dirTo] = {re: 1, im: 0};
      }
      return acc;
    }, {})
  );
});
